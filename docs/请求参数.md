## 查

**请求URL**

- ```python
  http://127.0.0.1:8000/books/
  url(r'^books/$', views.Book.as_view()),  # 群查
  
  http://127.0.0.1:8000/books/1/
  url(r'^books/(?P<pk>.*)/$', views.Book.as_view()),  # 单查
  ```

**请求方式**

- GET

**views**

```python
class V2Book(APIView):
    def get(self, request, *args, **kwargs):
        pk = kwargs.get('pk')
        if pk:  # 单查
            try:
                book_obj = models.Book.objects.get(pk=pk, is_deleted=False, is_show=True)
                book_ser = serializers.V2BookModelSerializer(book_obj).data
            except:
                return Response({
                    'status': 1,
                    'msg': '书籍不存在'
                })
        else:  # 群查
            book_query = models.Book.objects.filter(is_deleted=False, is_show=True)
            book_ser = serializers.V2BookModelSerializer(book_query, many=True).data

        return Response({
            'status': 200,
            'msg': 'ok',
            'results': book_ser
        })
```

## 增

**请求URL**

- ```python
  url(r'^books/$', views.Book.as_view()), 
  http://127.0.0.1:8000/v2books/
  # 单增
  {
      "name":"xxx",
      "price":15,
      "publish":1,
      "authors":[1]
  }     
  # 群增
  [
      {
      "name":"xxx",
      "price":15,
      "publish":1,
      "authors":[1]
  },{
      "name":"xxx",
      "price":15,
      "publish":1,
      "authors":[1]
  } 
  ]
  ```

**请求方式**

- POST

**views**

```python
def post(self, request, *args, **kwargs):
    '''
    单增: 传的数据是与model对应的一个字典
    群增：设计传递的是多个model对应的字典列表,在postman中通过列表嵌套字典传值
    '''
    request_data = request.data  # 拓展，兼容性最强，三种传参方式都可以：form-data,urlencoding,json
    if isinstance(request_data, dict):  # 判断获取的数据是否是dict
        many = False
        elif isinstance(request_data, list):  # 判断获取的数据是否是list
            many = True
            else:
                return Response({
                    'status': 1,
                    'msg': '数据错误'
                })
            book_ser = serializers.V2BookModelSerializer(data=request_data, many=many)
            # 检验是否合格 raise_exception=True必填的
            book_ser.is_valid(raise_exception=True)
            # book_result是对象<class 'app01.models.Book'>，群增就是列表套一个个对象
            book_obj = book_ser.save()
            return Response({
                'status': 200,
                'msg': 'ok',
                'results': serializers.BookModelSerializer(book_obj, many=many).data
            })
```

## 删

**请求URL**

- ```python
  url(r'^books/(?P<pk>.*)/$', views.Book.as_view())
  
  http://127.0.0.1:8000/books/1/  # 单删
  
  http://127.0.0.1:8000/books/{pks：[1,2,3]}  # 群删
  
  ```

**请求方式**

- GET

**views**

```python
def delete(self, request, *args, **kwargs):
    '''
        单删： 有pk —— 通过路径传参
        群删： 有pks —— 通过json传参
        '''
    pk = kwargs.get('pk')
    if pk:  # 单删
        pks = [pk]
        else:
            pks = request.data.get('pks')
            if models.Book.objects.filter(pk__in=pks, is_deleted=False).update(is_deleted=True):
                return Response({
                    'status': 0,
                    'msg': '删除成功'
                })
            return Response({
                'status': 1,
                'msg': '书籍不存在或已删除'
            })
```

## 改

**请求URL**

- ```python
  http://127.0.0.1:8000/books/1/
  url(r'^books/(?P<pk>.*)/$', views.Book.as_view()),  
  # 局部改
  http://127.0.0.1:8000/v2books/(PK)/
  {
  	"name":"11"
  }
  
  http://127.0.0.1:8000/v2books/(PK)/
  # 整体改
  {
      "name":"鲁月鹏2",
      "price":15,
      "publish":1,
      "authors":[1]
  }
  
  ```

**请求方式**

- GET

**views**

```python
   def put(self, request, *args, **kwargs):
        '''
        单整体改：对v2/books/(pk)传的数据是与model对应的字典{name|price|publish|authors}
        '''
        request_data = request.data
        pk = kwargs.get('pk')
        try:
            old_book_obj = models.Book.objects.get(pk=pk, is_deleted=False)
        except:
            # 当输入不存在的pk
            return Response({
                'status': 1,
                'msg': '参数错误'
            })
        # 目的：将众多数据的校验交给序列化类来处理 —— 让序列化类扮演反序列化角色校验成功后，序列化类来帮你入库
        book_ser = serializers.V2BookModelSerializer(instance=old_book_obj, data=request_data)
        book_ser.is_valid(raise_exception=True)
        # 校验通过，完成数据的更新：要更新的目标，用来更新的新数据
        book_obj = book_ser.save()
        return Response({
            'status': 0,
            'msg': 'ok',
            'results': serializers.V2BookModelSerializer(book_obj).data
        })

    def patch(self, request, *args, **kwargs):
        '''
        单局部改：对v2/books/(pk)传的数据，数据字段key都是选填
        '''
        request_data = request.data
        if not request_data:
            return Response({
                'status': 1,
                'msg': '请输入要修改的信息',

            })
        pk = kwargs.get('pk')

        try:
            old_book_obj = models.Book.objects.get(pk=pk, is_deleted=False)
        except:
            # 当输入不存在的pk
            return Response({
                'status': 1,
                'msg': '参数错误'
            })
        book_ser = serializers.V2BookModelSerializer(instance=old_book_obj, data=request_data, partial=True)
        book_ser.is_valid(raise_exception=True)
        book_obj = book_ser.save()
        return Response({
            'status': 0,
            'msg': 'ok',
            'results': serializers.V2BookModelSerializer(book_obj).data
        })
```

